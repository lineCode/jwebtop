#ifndef jwebtop_task_H_
#define jwebtop_task_H_

#include <string>
#include <thread>
#include <map>
#include <mutex>
#include <condition_variable>

using namespace std;
namespace jw{
	namespace task{
		//template  class __declspec(dllexport) std::allocator<wchar_t>;
		//template  class __declspec(dllexport) std::map < std::string, ProcessMsgLock* >;
		// 锁、任务执行结果包装类
		class /*_declspec(dllexport)*/ ProcessMsgLock
		{
		private:
			mutex lock;
			condition_variable g_queuecheck;
			bool notified = false;	// 用来标记是否已通知过（防止解锁通知在等待之前就发来，也为了在对象消耗时进行解锁）
			wstring result;			// 任务的执行结果（可能是js的执行结果，也可能是其他线程任务等）
			wstring taskId;			// 任务的唯一标识，这里采用uuid
		public:
			ProcessMsgLock(wstring taskId){ this->taskId = taskId; }
			~ProcessMsgLock(){ if (!notified)notify(L""); };
			wstring wait();					 // 等待执行结果：按defaultWaitTime进行等待
			wstring wait(DWORD microseconds);// 等待执行结果
			void notify(wstring result);	 // 设置执行结果
		};

		// map<key,value>,key=已成功发送到远程的任务的id，value=任务执行完成后放置任务执行结果
		typedef map<wstring, ProcessMsgLock * > WaitTaskMap;

		// 生成任务的id
		wstring createTaskId();

		// 添加一个等待任务到任务列表
		ProcessMsgLock * addTask(wstring taskId);

		// 移除已完成的任务
		void removeTask(wstring taskId);

		// 将任务执行结果保存进来，保存后会调用notify通知等待的程序：一般是在另外一个线程中调用
		bool putTaskResult(wstring taskId, wstring taskResult);

		// 把所有锁都给解锁：此方法当且仅当在进程退出时执行
		void unlockAndClearAll();

		// 设置任务的默认等待时间，如果不设置所有的等待任务会一直等下去（容易造成死锁）
		void setDefaultTaskWiatTime(DWORD defaultWaitTime);
	}
}
#endif